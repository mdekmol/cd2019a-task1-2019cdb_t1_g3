<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>CMSimfly 網際內容管理 - Python</title><link href="https://mdekmol.github.io/cd2019b-task1-2019cdb_t1_g3_1/blog/" rel="alternate"></link><link href="https://mdekmol.github.io/cd2019b-task1-2019cdb_t1_g3_1/blog/feeds/python.atom.xml" rel="self"></link><id>https://mdekmol.github.io/cd2019b-task1-2019cdb_t1_g3_1/blog/</id><updated>2019-03-29T16:00:00+08:00</updated><entry><title>Week6</title><link href="https://mdekmol.github.io/cd2019b-task1-2019cdb_t1_g3_1/blog/cd2019b-task1-2019cdb-t1-g3-1/0329.html" rel="alternate"></link><published>2019-03-29T16:00:00+08:00</published><updated>2019-03-29T16:00:00+08:00</updated><author><name>yen</name></author><id>tag:mdekmol.github.io,2019-03-29:/cd2019b-task1-2019cdb_t1_g3_1/blog/cd2019b-task1-2019cdb-t1-g3-1/0329.html</id><summary type="html"></summary><content type="html"></content><category term="2018FallCP"></category></entry><entry><title>Week5</title><link href="https://mdekmol.github.io/cd2019b-task1-2019cdb_t1_g3_1/blog/cd2019b-task1-2019cdb-t1-g3-1/0322.html" rel="alternate"></link><published>2019-03-22T16:00:00+08:00</published><updated>2019-03-22T16:00:00+08:00</updated><author><name>yen</name></author><id>tag:mdekmol.github.io,2019-03-22:/cd2019b-task1-2019cdb_t1_g3_1/blog/cd2019b-task1-2019cdb-t1-g3-1/0322.html</id><summary type="html">&lt;p&gt;V-rep BubbleRob&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;依照http://www.coppeliarobotics.com/helpFiles/en/bubbleRobTutorial.htm 步驟&lt;/p&gt;
&lt;p&gt;Add a primitive sphere of diameter 0.2 to the scene with [Menu bar --&amp;gt; Add --&amp;gt; Primitive shape --&amp;gt; Sphere].&lt;/p&gt;
&lt;p&gt;使用[菜單欄(Menu bar) - &amp;gt;添加(Add) - &amp;gt;原始形狀(Primitive shape) - &amp;gt;球體(Sphere)]向場景添加直徑為0.2的球體。&lt;/p&gt;
&lt;p&gt;We adjust the X-size item to 0.2 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;V-rep BubbleRob&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;依照http://www.coppeliarobotics.com/helpFiles/en/bubbleRobTutorial.htm 步驟&lt;/p&gt;
&lt;p&gt;Add a primitive sphere of diameter 0.2 to the scene with [Menu bar --&amp;gt; Add --&amp;gt; Primitive shape --&amp;gt; Sphere].&lt;/p&gt;
&lt;p&gt;使用[菜單欄(Menu bar) - &amp;gt;添加(Add) - &amp;gt;原始形狀(Primitive shape) - &amp;gt;球體(Sphere)]向場景添加直徑為0.2的球體。&lt;/p&gt;
&lt;p&gt;We adjust the X-size item to 0.2, then click OK.&lt;/p&gt;
&lt;p&gt;將X-size項目調整為0.2，然後點擊“OK”。&lt;/p&gt;
&lt;p&gt;The created sphere will appear in the visibility layer 1 by default, and be dynamic and respondable&lt;/p&gt;
&lt;p&gt;默認情況下，創建的球體將顯示在可見性圖層1中，並且是動態且可響應的&lt;/p&gt;
&lt;p&gt;This means that BubbleRob's body will be falling and able to react to collisions with other respondable shapes(i.e. simulated by the physics engine). &lt;/p&gt;
&lt;p&gt;這意味著BubbleRob的身體將會下降，並能夠對與其他可響應形狀的碰撞作出反應（即由物理引擎模擬）&lt;/p&gt;
&lt;p&gt;Enable Collidable, Measurable, Renderable and Detectable in the object common properties for that shape&lt;/p&gt;
&lt;p&gt;在該形狀的公共屬性中啟用Collidable，Measurable，Renderable和Detectable&lt;/p&gt;
&lt;p&gt;open the position dialog on the translation tab, select the sphere representing BubbleRob's body, and enter 0.02 for Along Z. &lt;/p&gt;
&lt;p&gt;在平移選項卡上打開位置對話框，選擇代表BubbleRob主體的球體，並在Along Z輸入0.02。&lt;/p&gt;
&lt;p&gt;We make sure that the Relative to-item is set to World. Then we click Translate selection.&lt;/p&gt;
&lt;p&gt;我們確保將相對項目設置為世界。 然後我們點擊改動選擇。&lt;/p&gt;
&lt;p&gt;Add a proximity sensor [Menu bar --&amp;gt; Add --&amp;gt; Proximity sensor --&amp;gt; Cone type]&lt;/p&gt;
&lt;p&gt;添加接近傳感器[菜單欄 - &amp;gt;添加 - &amp;gt;接近傳感器 - &amp;gt;錐形]&lt;/p&gt;
&lt;p&gt;In the orientation dialog on the orientation tab, we enter 90 for Around Y and for Around Z, then click Rotate selection&lt;/p&gt;
&lt;p&gt;在方向選項卡上的方向對話框中，我們為Y和Z輸入90，然後點擊旋轉&lt;/p&gt;
&lt;p&gt;In the position dialog, on the position tab, we enter 0.1 for X-coord. and 0.12 for Z-coord. &lt;/p&gt;
&lt;p&gt;在位置對話框中，在平移選項卡上，我們為X-coord輸入0.1。 Z-coord為0.12。&lt;/p&gt;
&lt;p&gt;Click Show volume parameter adjust items Offset to 0.005, Angle to 30 and Range to 0.15.&lt;/p&gt;
&lt;p&gt;單擊顯示體積參數調整項目偏移量為0.005，角度為30，範圍為0.15。&lt;/p&gt;
&lt;p&gt;Click Show detection parameters uncheck item Don't allow detections if distance smaller than.&lt;/p&gt;
&lt;p&gt;單擊顯示檢測參數取消選中項目如果距離小於，則不允許檢測。&lt;/p&gt;
&lt;p&gt;Add a pure primitive cylinder with dimensions,size(0.08,0.08,0.02).&lt;/p&gt;
&lt;p&gt;添加尺寸，尺寸（0.08,0.08,0.02）的純原始圓柱體。&lt;/p&gt;
&lt;p&gt;Set the cylinder's absolute position to (0.05,0.1,0.04).Set absolute orientation to (-90,0,0).&lt;/p&gt;
&lt;p&gt;將氣缸的絕對位置設為（0.05,0.1,0.04），將絕對方向設置為（-90,0,0）。&lt;/p&gt;
&lt;p&gt;Copy and paste the wheel, and set the absolute Y coordinate of the copy to -0.1.&lt;/p&gt;
&lt;p&gt;複製並貼上滾輪，並將副本的絕對Y坐標設置為-0.1。&lt;/p&gt;
&lt;p&gt;Add joints (or motors) for the wheels. Click [Menu bar --&amp;gt; Add --&amp;gt; Joint --&amp;gt; Revolute]&lt;/p&gt;
&lt;p&gt;為車輪添加接頭（或馬達）。 單擊[菜單欄 - &amp;gt;添加 - &amp;gt;關節 - &amp;gt; Revolute]&lt;/p&gt;
&lt;p&gt;On the position tab, click the Apply to selection button.&lt;/p&gt;
&lt;p&gt;在位置選項卡上，單擊“應用於選擇”按鈕&lt;/p&gt;
&lt;p&gt;On the orientation tab, click the Apply to selection button.&lt;/p&gt;
&lt;p&gt;在方向選項卡上，單擊“應用於選擇”按鈕&lt;/p&gt;
&lt;p&gt;Attach the left wheel to the left motor ,and attach motor to BubbleRob.Attach the right wheel to the right motor ,and attach motor to BubbleRob.&lt;/p&gt;
&lt;p&gt;將左側車輪連接到左側電機，並將電機連接到BubbleRob。將右側車輪安裝到右側電機，然後將電機連接到BubbleRob。&lt;/p&gt;
&lt;p&gt;Click Show dynamic parameters to open the joint dynamics properties dialog. We enable the motor, and check item Lock motor when target velocity is zero.&lt;/p&gt;
&lt;p&gt;單擊顯示動態參數以打開關節動力學屬性對話框。 啟用馬達，並在目標速度為零時檢查項目鎖定馬達。&lt;/p&gt;
&lt;p&gt;Add a pure primitive sphere with diameter 0.05 and make the sphere Collidable, Measurable, Renderable and Detectable. set absolute position to(-0.07,0,0).&lt;/p&gt;
&lt;p&gt;添加直徑為0.05的純原始球體，使球體具有可碰撞，可測量，可表示和可檢測的範圍。 將絕對位置設置為（-0.07,0,0）。&lt;/p&gt;
&lt;p&gt;Add a force sensor object with [Menu bar --&amp;gt; Add --&amp;gt; Force sensor]. set absolute position to(-0.07,0,0.05)&lt;/p&gt;
&lt;p&gt;使用[菜單欄 - &amp;gt;添加 - &amp;gt;力傳感器]添加力傳感器對象。 將絕對位置設為（-0.07,0,0.05）&lt;/p&gt;
&lt;p&gt;Attach the slider to the force sensor&lt;/p&gt;
&lt;p&gt;將滑塊連接到力傳感器&lt;/p&gt;
&lt;p&gt;將bubbleRob的物體碰撞響應遮罩設置為00001111&lt;/p&gt;
&lt;p&gt;bubbleRob_slider set the local respondable mask to 00001111&lt;/p&gt;
&lt;p&gt;bubbleRob set the local respondable mask to 11110000&lt;/p&gt;
&lt;p&gt;將滑塊的物體碰撞響應遮罩設置為11110000&lt;/p&gt;
&lt;p&gt;select the two wheels and the slider, and in the shape dynamics dialog we click three times M=M*2 .&lt;/p&gt;
&lt;p&gt;選擇兩個輪子和滑塊，在形狀動態對話框中我們單擊三次M = M * 2。&lt;/p&gt;
&lt;p&gt;Enabled Collidable, Measurable, Renderable and Detectable.&lt;/p&gt;
&lt;p&gt;啟用可碰撞，可測量，可表示和可檢測。&lt;/p&gt;
&lt;p&gt;Click Add new collection.Select bubbleRob  and then click Add in the collection dialog.&lt;/p&gt;
&lt;p&gt;單擊“添加新集合”選擇bubbleRob，然後在集合對話框中單擊“添加”。&lt;/p&gt;
&lt;p&gt;Click Add new distance object in  distance dialog.Select a distance pair: [collection] collection - all other measurable objects in the scene. &lt;/p&gt;
&lt;p&gt;單擊距離對話框中的添加新距離目標。選擇距離配對：[集合]集合 - 場景中的所有其他可測量對象。&lt;/p&gt;
&lt;p&gt;Add a graph object Click [Menu bar --&amp;gt; Add --&amp;gt; Graph].Attach the graph to bubbleRob, and set the absolute coordinates to (0,0,0.005).&lt;/p&gt;
&lt;p&gt;添加圖形對象單擊[菜單欄 - &amp;gt;添加 - &amp;gt;圖形]。
將圖形附加到bubbleRob，並將絕對坐標設置為（0,0,0.005）。&lt;/p&gt;
&lt;p&gt;uncheck Display XYZ-planes.Click Add new data stream to record &lt;/p&gt;
&lt;p&gt;取消選中顯示XYZ平面。單擊“添加要記錄的新數據流”&lt;/p&gt;
&lt;p&gt;select Object: absolute x-position for the Data stream type, and graph for the Object / item to record. Record the y and z positions.&lt;/p&gt;
&lt;p&gt;選擇對象：數據流類型的絕對x位置，以及要記錄的對象/項目的圖形。 記錄y和z位置。&lt;/p&gt;
&lt;p&gt;select Distance: segment length for the Data stream type, and bubbleRob_distance for the Object / item to record.&lt;/p&gt;
&lt;p&gt;選擇距離：數據流類型的段長度，以及要記錄的對象/項目的bubbleRob_distance。&lt;/p&gt;
&lt;p&gt;Set x y z postion uncheck Visible.&lt;/p&gt;
&lt;p&gt;設置x y z postion取消選中Visible。&lt;/p&gt;
&lt;p&gt;Click Edit 3D curves, then click Add new curve. &lt;/p&gt;
&lt;p&gt;bubbleRob_x_pos for the X-value item&lt;/p&gt;
&lt;p&gt;bubbleRob_y_pos for the Y-value item&lt;/p&gt;
&lt;p&gt;bubbleRob_z_pos for the Z-value item&lt;/p&gt;
&lt;p&gt;單擊“編輯3D曲線”，然後單擊“添加新曲線”。&lt;/p&gt;
&lt;p&gt;bubble值為bubbleRob_x_pos，用於X值項目&lt;/p&gt;
&lt;p&gt;bubble值為bubbleRob_y_pos，用於Y值項目&lt;/p&gt;
&lt;p&gt;bubble值為bubbleRob_z_pos，用於Z值項目&lt;/p&gt;
&lt;p&gt;check the Relative to world item and set Curve width to 4.&lt;/p&gt;
&lt;p&gt;選中“相對於世界”項並將“曲線寬度”設置為4。&lt;/p&gt;
&lt;p&gt;Add a pure primitive cylinder:(0.1, 0.1, 0.2). &lt;/p&gt;
&lt;p&gt;添加一個純原始圓柱體：（0.1,0.1,0.2）。&lt;/p&gt;
&lt;p&gt;Disable Body is dynamic.Enable Collidable, Measurable, Renderable and Detectable.&lt;/p&gt;
&lt;p&gt;取消勾選圓柱體是動態的。啟用可碰撞，可測量，可表示和可檢測。&lt;/p&gt;
&lt;p&gt;Copy and paste the cylinder a few times, and move them to positions around BubbleRob.&lt;/p&gt;
&lt;p&gt;複製並貼上圓柱體幾次，然後將它們移動到BubbleRob周圍的位置。&lt;/p&gt;
&lt;p&gt;Select the model base (BubbleRob) then check items Object is model base and Object/model can transfer or accept DNA.&lt;/p&gt;
&lt;p&gt;選擇模型庫（BubbleRob）然後檢查項目對像是模型庫，對象/模型可以傳輸或接受DNA。&lt;/p&gt;
&lt;p&gt;Select the two joints, the proximity sensor and the graph, then enable item Igonred by model bounding box and click Apply to selection.&lt;/p&gt;
&lt;p&gt;選擇兩個關節，接近傳感器和圖形，然後通過模型邊界框啟用項目Igonred，然後點擊應用於選擇。&lt;/p&gt;
&lt;p&gt;Select the vision sensor, the two wheels, the slider, and the graph, then enable item Select base of model instead.&lt;/p&gt;
&lt;p&gt;選擇視覺傳感器，兩個輪子，滑塊和圖形，然後啟用項目選擇模型基礎。&lt;/p&gt;
&lt;p&gt;Add a vision sensor,click [Menu bar --&amp;gt; Add --&amp;gt; Vision sensor --&amp;gt; Perspective type]
At the same position and orientation as BubbleRob's proximity sensor,then attach the vision sensor to the proximity sensor.&lt;/p&gt;
&lt;p&gt;添加視覺傳感器，單擊[菜單欄 - &amp;gt;添加 - &amp;gt;視覺傳感器 - &amp;gt;透視類型]在與BubbleRob的接近傳感器相同的位置和方向，然後將視覺傳感器連接到接近傳感器。&lt;/p&gt;
&lt;p&gt;Set the local position and orientation of the vision sensor to (0,0,0).
Set the Far clipping plane item to 1, and the Resolution x and Resolution y items to 256 and 256.&lt;/p&gt;
&lt;p&gt;將視覺傳感器的本地位置和方向設置為（0,0,0）。將遠剪裁平面項目設置為1，將分辨率x和分辨率y項目設置為256和256。&lt;/p&gt;
&lt;p&gt;Clicking Show filter dialog. We select the filter component Edge detection on work image and click Add filter. We position the newly added filter in second position (one position up, using the up button).&lt;/p&gt;
&lt;p&gt;單擊“顯示過濾器”對話框 我們在工作圖像上選擇過濾器組件邊緣檢測，然後單擊添加過濾器。 將新添加的過濾器定位在第二個位置（一個位置向上，使用向上按鈕）。&lt;/p&gt;
&lt;p&gt;Double-click the newly added filter component and adjust its Threshold item to 0.2.&lt;/p&gt;
&lt;p&gt;雙擊新添加的過濾器組件，並將其臨界調整為0.2。&lt;/p&gt;
&lt;p&gt;Add a floating view.Right-click [Popup menu --&amp;gt; View --&amp;gt; Associate view with selected vision sensor].&lt;/p&gt;
&lt;p&gt;添加浮動視圖。右鍵點擊[彈出菜單 - &amp;gt;視圖 - &amp;gt;關聯視圖與選定的視覺傳感器]。&lt;/p&gt;
&lt;p&gt;Select bubbleRob and click [Menu bar --&amp;gt; Add --&amp;gt; Associated child script --&amp;gt; Non threaded].&lt;/p&gt;
&lt;p&gt;選擇bubbleRob並點擊[菜單欄 - &amp;gt;添加 - &amp;gt;關聯的子腳本 - &amp;gt;非線程]。&lt;/p&gt;
&lt;p&gt;copy and paste following code into the script editor&lt;/p&gt;
&lt;p&gt;將以下代碼複製並粘貼到腳本編輯器中&lt;/p&gt;
&lt;p&gt;function speedChange_callback(ui,id,newVal)
    speed=minMaxSpeed[1]+(minMaxSpeed[2]-
minMaxSpeed[1])&lt;em&gt;newVal/100
end
 function sysCall_init()
    -- This is executed exactly once, the first time this 
script is executed
    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self) -- this is bubbleRob's handle
    leftMotor=sim.getObjectHandle("bubbleRob_leftMotor") -- Handle of the left motor
    rightMotor=sim.getObjectHandle("bubbleRob_rightMotor") -- Handle of the right motor
    noseSensor=sim.getObjectHandle("bubbleRob_sensingNose") -- Handle of the proximity sensor
    minMaxSpeed={50&lt;/em&gt;math.pi/180,300&lt;em&gt;math.pi/180} -- Min and max speeds for each motor
    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode
    -- Create the custom UI:
        xml = '&lt;ui title="'..sim.getObjectName(bubbleRobBase)..' speed" closeable="false" resizeable="false" activate="false"&gt;'..[[
        &lt;hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/&gt;
        &lt;label text="" style="* {margin-left: 300px;}"/&gt;
        &lt;/ui&gt;
        ]]
    ui=simUI.create(xml)
    speed=(minMaxSpeed[1]+minMaxSpeed[2])&lt;/em&gt;0.5
    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))
end
function sysCall_actuation()
    result=sim.readProximitySensor(noseSensor) -- Read the proximity sensor
    -- If we detected something, we set the backward mode:
    if (result&amp;gt;0) then backUntilTime=sim.getSimulationTime()+4 end
    if (backUntilTime&amp;lt;sim.getSimulationTime()) then
        -- When in forward mode, we simply move forward at the desired speed
        sim.setJointTargetVelocity(leftMotor,speed)
        sim.setJointTargetVelocity(rightMotor,speed)
    else
        -- When in backward mode, we simply backup in a curve at reduced speed
        sim.setJointTargetVelocity(leftMotor,-speed/2)
        sim.setJointTargetVelocity(rightMotor,-speed/8)
    end
end&lt;/p&gt;
&lt;p&gt;function sysCall_cleanup()
    simUI.destroy(ui)
end&lt;/p&gt;</content><category term="2018FallCP"></category></entry><entry><title>Week4</title><link href="https://mdekmol.github.io/cd2019b-task1-2019cdb_t1_g3_1/blog/cd2019b-task1-2019cdb-t1-g3-1/0315.html" rel="alternate"></link><published>2019-03-15T16:00:00+08:00</published><updated>2019-03-15T16:00:00+08:00</updated><author><name>yen</name></author><id>tag:mdekmol.github.io,2019-03-15:/cd2019b-task1-2019cdb_t1_g3_1/blog/cd2019b-task1-2019cdb-t1-g3-1/0315.html</id><summary type="html">&lt;p&gt;配置 ungit
下載 ungit 與 node.js 程式碼&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;根據 https://2019wcm.blogspot.com/search/label/ungit 完成ungit的配置&lt;/p&gt;
&lt;p&gt;1.下載  kmol-2019.7z , 接著再下載 nodejs-with-ungit.7z, 兩者分別解開壓縮檔案, 然後將 nodejs 放入 kmol_2019 的 data 目錄中.&lt;/p&gt;
&lt;p&gt;2.設定命令列搜尋路徑&lt;/p&gt;
&lt;p&gt;3.設定啟動 start.bat 中的 ungit 命列列搜尋路徑:&lt;/p&gt;
&lt;p&gt;set path8=%Disk%:\nodejs;%Disk%:\nodejs\appdata\roaming\npm …&lt;/p&gt;</summary><content type="html">&lt;p&gt;配置 ungit
下載 ungit 與 node.js 程式碼&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;根據 https://2019wcm.blogspot.com/search/label/ungit 完成ungit的配置&lt;/p&gt;
&lt;p&gt;1.下載  kmol-2019.7z , 接著再下載 nodejs-with-ungit.7z, 兩者分別解開壓縮檔案, 然後將 nodejs 放入 kmol_2019 的 data 目錄中.&lt;/p&gt;
&lt;p&gt;2.設定命令列搜尋路徑&lt;/p&gt;
&lt;p&gt;3.設定啟動 start.bat 中的 ungit 命列列搜尋路徑:&lt;/p&gt;
&lt;p&gt;set path8=%Disk%:\nodejs;%Disk%:\nodejs\appdata\roaming\npm;&lt;/p&gt;
&lt;p&gt;4.將 path8 納入 path 設定:&lt;/p&gt;
&lt;p&gt;path=%path%;%path1%;%path2%;%path3%;%path4%;%path5%;%path6%;%path7%;%Disk%:\p37\site-packages\scipy\extra_dll;%Disk%:\scite\bin;%path8%;&lt;/p&gt;
&lt;h1&gt;Youtube 連結： https://www.youtube.com/watch?v=lB-spECfhr8&lt;/h1&gt;</content><category term="2018FallCP"></category></entry><entry><title>Week2</title><link href="https://mdekmol.github.io/cd2019b-task1-2019cdb_t1_g3_1/blog/cd2019b-task1-2019cdb-t1-g3-1/0301.html" rel="alternate"></link><published>2019-03-01T16:00:00+08:00</published><updated>2019-03-01T16:00:00+08:00</updated><author><name>yen</name></author><id>tag:mdekmol.github.io,2019-03-01:/cd2019b-task1-2019cdb_t1_g3_1/blog/cd2019b-task1-2019cdb-t1-g3-1/0301.html</id><summary type="html"></summary><content type="html"></content><category term="2018FallCP"></category></entry><entry><title>Week1</title><link href="https://mdekmol.github.io/cd2019b-task1-2019cdb_t1_g3_1/blog/cd2019b-task1-2019cdb-t1-g3-1/0222.html" rel="alternate"></link><published>2019-02-22T16:00:00+08:00</published><updated>2019-02-22T16:00:00+08:00</updated><author><name>yen</name></author><id>tag:mdekmol.github.io,2019-02-22:/cd2019b-task1-2019cdb_t1_g3_1/blog/cd2019b-task1-2019cdb-t1-g3-1/0222.html</id><summary type="html"></summary><content type="html"></content><category term="2018FallCP"></category></entry><entry><title>Python Getting Started</title><link href="https://mdekmol.github.io/cd2019b-task1-2019cdb_t1_g3_1/blog/2018-Fall-Python-Getting-Started.html" rel="alternate"></link><published>2018-09-11T11:00:00+08:00</published><updated>2018-09-11T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:mdekmol.github.io,2018-09-11:/cd2019b-task1-2019cdb_t1_g3_1/blog/2018-Fall-Python-Getting-Started.html</id><summary type="html">&lt;p&gt;以下程式架構取自 &lt;a href="http://lab.kmol.info/blog/brython-programming-environment.html"&gt;http://lab.kmol.info/blog/brython-programming-environment.html&lt;/a&gt;, 使用 static/py/ 目錄中的 ace.py 程式定義.&lt;/p&gt;


&lt;!-- 導入 FileSaver 與 filereader --&gt;

&lt;script type="text/javascript" src="./../static/ace/FileSaver.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../static/ace/filereader.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../static/brython.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../static/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 導入平面機構模擬所需程式庫 --&gt;

&lt;!-- sylvester.js 為向量、矩陣與幾何程式庫 http://sylvester.jcoglan.com/ --&gt;

&lt;script src="./../static/sylvester/sylvester.js"&gt;&lt;/script&gt;

&lt;!-- PrairieDraw.js 為延伸 sylvester.js 的 html5 canvas 繪圖應用程式庫 https://github.com/martin70/PrairieDraw.js --&gt;

&lt;script src="./../static/sylvester/PrairieDraw.js"&gt;&lt;/script&gt;

&lt;style&gt;
canvas {
    border: 1px solid black;
}
&lt;/style&gt;

&lt;script&gt;
window.onload=function(){
brython({debug:1, pythonpath:['./../static']});
}
&lt;/script&gt;

&lt;!-- 以下執行 Brython 程式 --&gt;

&lt;script src="./../static/ace/ace.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../static/ace/ext-language_tools.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../static/ace/mode-python3.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../static/ace/snippets/python.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--&gt;

&lt;script type="text/javascript"&gt;
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob …&lt;/script&gt;</summary><content type="html">&lt;p&gt;以下程式架構取自 &lt;a href="http://lab.kmol.info/blog/brython-programming-environment.html"&gt;http://lab.kmol.info/blog/brython-programming-environment.html&lt;/a&gt;, 使用 static/py/ 目錄中的 ace.py 程式定義.&lt;/p&gt;


&lt;!-- 導入 FileSaver 與 filereader --&gt;

&lt;script type="text/javascript" src="./../static/ace/FileSaver.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../static/ace/filereader.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../static/brython.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../static/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 導入平面機構模擬所需程式庫 --&gt;

&lt;!-- sylvester.js 為向量、矩陣與幾何程式庫 http://sylvester.jcoglan.com/ --&gt;

&lt;script src="./../static/sylvester/sylvester.js"&gt;&lt;/script&gt;

&lt;!-- PrairieDraw.js 為延伸 sylvester.js 的 html5 canvas 繪圖應用程式庫 https://github.com/martin70/PrairieDraw.js --&gt;

&lt;script src="./../static/sylvester/PrairieDraw.js"&gt;&lt;/script&gt;

&lt;style&gt;
canvas {
    border: 1px solid black;
}
&lt;/style&gt;

&lt;script&gt;
window.onload=function(){
brython({debug:1, pythonpath:['./../static']});
}
&lt;/script&gt;

&lt;!-- 以下執行 Brython 程式 --&gt;

&lt;script src="./../static/ace/ace.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../static/ace/ext-language_tools.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../static/ace/mode-python3.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../static/ace/snippets/python.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--&gt;

&lt;script type="text/javascript"&gt;
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
&lt;/script&gt;

&lt;p&gt;編寫 Python3 程式邏輯之前必須先了解基本的程式語法, 其中包括:&lt;/p&gt;
&lt;h2&gt;Python3 變數命名規則與關鍵字&lt;/h2&gt;
&lt;p&gt;Python 英文變數命名規格&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;變數必須以英文字母大寫或小寫或底線開頭
變數其餘字元可以是英文大小寫字母, 數字或底線
變數區分英文大小寫
變數不限字元長度
不可使用關鍵字當作變數名稱
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用者可以利用以下程式列出所使用 Python 的版次與關鍵字:&lt;/p&gt;
&lt;!-- 印出版次與關鍵字程式 --&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="kw_editor", console_id="kw_console", container_id="kw__container", storage_id="kw_py_src" )

Ace.editor.setValue('''# 導入 sys 模組
import sys
# 導入 keyword 模組
import keyword

# 利用 sys 模組中的 version_info 印出 Python 版次
print("Python version: ", sys.version_info)
# 利用 keyword 模組中的 kwlist 印出關鍵字
print("Python keywords: ", keyword.kwlist)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run'].bind('click', Ace.run)
doc['kw_show_console'].bind('click', Ace.show_console)
doc['kw_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="kw_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="kw_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('kw_py_src', 'kw_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="kw_run"&gt;Run&lt;/button&gt;
&lt;button id="kw_show_console"&gt;Output&lt;/button&gt;
&lt;button id="kw_clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="kw_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Python3 的程式關鍵字, 使用者命名變數時, 必須避開下列保留字.&lt;/p&gt;
&lt;p&gt;Python keywords:  ['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']&lt;/p&gt;
&lt;p&gt;選擇好的變數名稱:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;使用有意義且適當長度的變數名稱， 例如: 使用 length 代表長度, 不要單獨使用 l 或 L, 也不要使用 this_is_the_length
程式前後變數命名方式盡量一致, 例如: 使用 rect_length 或 RectLength
用底線開頭的變數通常具有特殊意義
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;print() 函式用法&lt;/h2&gt;
&lt;p&gt;print() 為 Python 程式語言中用來列印數值或字串的函式, 其中有 sep 變數定義分隔符號, sep 內定為 ",", end 變數則用來定義列印結尾的符號, end 內定為跳行符號.&lt;/p&gt;
&lt;h2&gt;for 迴圈用法與 Python 的縮排規定&lt;/h2&gt;
&lt;p&gt;重複迴圈用法, 使用者可以透過下列程式編輯區練習 for 迴圈與 print() 函式的用法.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

Ace = ace.Editor(editor_id="editor", console_id="console", container_id="first_container", storage_id="py_src" )

Ace.editor.setValue('''#ex1 簡單的 for 迴圈範例
for i in range(10):
    print(i)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['run'].bind('click', Ace.run)
doc['show_console'].bind('click', Ace.show_console)
doc['clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('py_src', 'filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="run"&gt;Run&lt;/button&gt;
&lt;button id="show_console"&gt;Output&lt;/button&gt;
&lt;button id="clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;函式用法與呼叫&lt;/h2&gt;
&lt;p&gt;使用者可以利用下列程式, 練習 def 函式定義與呼叫的用法.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

Ace = ace.Editor(editor_id="fun_editor", console_id="fun_console", container_id="fun_container", storage_id="fun_py_src" )

Ace.editor.setValue('''# 定義函式
def square_of_x(x):
    return x*x

# 呼叫函式
y = square_of_x(3)
# 列印 y 對應內容
print(y)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['fun_run'].bind('click', Ace.run)
doc['fun_show_console'].bind('click', Ace.show_console)
doc['fun_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="fun_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="fun_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('fun_py_src', 'fun_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="fun_run"&gt;Run&lt;/button&gt;
&lt;button id="fun_show_console"&gt;Output&lt;/button&gt;
&lt;button id="fun_clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="fun_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;!-- Brython 的網際繪圖 --&gt;

&lt;p&gt;以下網際繪圖程式, 僅提供參考.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

Ace = ace.Editor(editor_id="by_editor", console_id="by_console", container_id="by_container", storage_id="by_py_src" )

Ace.editor.setValue('''# First of all, the import of some libraries
from browser import document as doc
from browser import html

# All the elements will be inserted in the div with the "container" id
container = doc['by_container']

# We create a new div element
newdiv = html.DIV(id = "new-div")
# Now we add some style
newdiv.style = {"padding": "5px", 
               "backgroundColor": "#ADD8E6"}

# Now, lets add a table with a column with numbers and a
# column with a word on each cell
text = "Brython is really cool"
textlist = text.split()
table = html.TABLE()
for i, word in enumerate(textlist):
    table &lt;= html.TR(html.TD(i + 1) + 
                     html.TD(word))
# Now we add some style to the table
table.style = {"padding": "5px", 
               "backgroundColor": "#aaaaaa",
               "width": "100%"}
# Now we add the table to the new div previously created
newdiv &lt;= table + html.BR()

# a form? why not?
form = html.FORM()
input1 = html.INPUT(type="text", name="firstname", value="First name")
input2 = html.INPUT(type="text", name="lastname", value="Last name")
input3 = html.BUTTON("Button with no action!")
form &lt;= input1 + html.BR() + input2 + html.BR() + input3

newdiv &lt;= form + html.BR()

# Finally, we will add something more 'HTML5istic', a canvas with
# a color gradient in the newdiv previously created and below the form
canvas = html.CANVAS(width = 300, height = 300)
#canvas.style = {"width": "100%"}
ctx = canvas.getContext('2d')
ctx.rect(0, 0, 300, 300)
grd = ctx.createRadialGradient(150, 150, 10, 150, 150, 150)
grd.addColorStop(0, '#8ED6FF')
grd.addColorStop(1, '#004CB3')
ctx.fillStyle = grd
ctx.fill()

newdiv &lt;= canvas
# And finally we append the newdiv element
# to the parent, in this case the div with the "container" id
container &lt;= newdiv
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['by_run'].bind('click', Ace.run)
doc['by_show_console'].bind('click', Ace.show_console)
doc['by_clear_console'].bind('click', Ace.clear_console)
doc['by_clear_container'].bind('click', Ace.clear_container)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="by_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="by_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('by_py_src', 'by_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="by_run"&gt;Run&lt;/button&gt;
&lt;button id="by_show_console"&gt;Output&lt;/button&gt;
&lt;button id="by_clear_console"&gt;清除&lt;/button&gt;
&lt;button id="by_clear_container"&gt;清除畫布&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="by_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;
&lt;div id="by_container"&gt;&lt;/div&gt;&lt;/p&gt;
&lt;!-- Brython 動畫 --&gt;

&lt;p&gt;以下網際動態繪圖程式, 僅提供參考.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

Ace = ace.Editor(editor_id="clock_editor", console_id="clock_console", container_id="clock_container", storage_id="clock_py_src" )

Ace.editor.setValue('''# First of all, the import of some libraries
import time
import math
import datetime
from browser import document as doc
import browser.timer
from browser import html

sin,cos = math.sin,math.cos
width,height = 250,250 # canvas dimensions
ray = 100 # clock ray

# All the elements will be inserted in the div with the "container" id
container = doc['clock_container']

# We create a new div element
newdiv = html.DIV(id = "new-div")
# Now we add some style
newdiv.style = {"padding": "5px", 
               "backgroundColor": "#ADD8E6"}

canvas = html.CANVAS(width = width, height = height)
#canvas.style = {"width": "100%"}
ctx = canvas.getContext('2d')

def needle(angle,r1,r2,color="#000000"):
    # draw a needle at specified angle in specified color
    # r1 and r2 are percentages of clock ray
    x1 = width/2-ray*cos(angle)*r1
    y1 = height/2-ray*sin(angle)*r1
    x2 = width/2+ray*cos(angle)*r2
    y2 = height/2+ray*sin(angle)*r2
    ctx.beginPath()
    ctx.strokeStyle = color
    ctx.moveTo(x1,y1)
    ctx.lineTo(x2,y2)
    ctx.stroke()

def set_clock():
    # erase clock
    ctx.beginPath()
    ctx.fillStyle = "#FFF"
    ctx.arc(width/2,height/2,ray*0.89,0,2*math.pi)
    ctx.fill()

    # redraw hours
    show_hours()

    # print day
    now = datetime.datetime.now()
    day = now.day
    ctx.font = "bold 14px Arial"
    ctx.textAlign = "center"
    ctx.textBaseline = "middle"
    ctx.fillStyle="#FFF"
    ctx.fillText(day,width*0.7,height*0.5)

    # draw needles for hour, minute, seconds    
    ctx.lineWidth = 3
    hour = now.hour%12 + now.minute/60
    angle = hour*2*math.pi/12 - math.pi/2
    needle(angle,0.05,0.5)
    minute = now.minute
    angle = minute*2*math.pi/60 - math.pi/2
    needle(angle,0.05,0.85)
    ctx.lineWidth = 1
    second = now.second+now.microsecond/1000000
    angle = second*2*math.pi/60 - math.pi/2
    needle(angle,0.05,0.85,"#FF0000") # in red

browser.timer.set_interval(set_clock,100)

ctx.beginPath()
ctx.lineWidth = 10
ctx.arc(width/2,height/2,ray,0,2*math.pi)
ctx.stroke()

for i in range(60):
    ctx.lineWidth = 1
    if i%5 == 0:
        ctx.lineWidth = 3
    angle = i*2*math.pi/60 - math.pi/3
    x1 = width/2+ray*cos(angle)
    y1 = height/2+ray*sin(angle)
    x2 = width/2+ray*cos(angle)*0.9
    y2 = height/2+ray*sin(angle)*0.9
    ctx.beginPath()
    ctx.moveTo(x1,y1)
    ctx.lineTo(x2,y2)
    ctx.stroke()

def show_hours():
    ctx.beginPath()
    ctx.arc(width/2,height/2,ray*0.05,0,2*math.pi)
    ctx.fillStyle = "#000"
    ctx.fill()
    for i in range(1,13):
        angle = i*math.pi/6-math.pi/2
        x3 = width/2+ray*cos(angle)*0.75
        y3 = height/2+ray*sin(angle)*0.75
        ctx.font = "20px Arial"
        ctx.textAlign = "center"
        ctx.textBaseline = "middle"
        ctx.fillText(i,x3,y3)
    # cell for day
    ctx.fillStyle = "#000"
    ctx.fillRect(width*0.65,height*0.47,width*0.1,height*0.06)

show_hours()
set_clock()

newdiv &lt;= canvas
# And finally we append the newdiv element
# to the parent, in this case the div with the "container" id
container &lt;= newdiv
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['clock_run'].bind('click', Ace.run)
doc['clock_show_console'].bind('click', Ace.show_console)
doc['clock_clear_console'].bind('click', Ace.clear_console)
doc['clock_clear_container'].bind('click', Ace.clear_container)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="clock_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="clock_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('clock_py_src', 'clock_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="clock_run"&gt;Run&lt;/button&gt;
&lt;button id="clock_show_console"&gt;Output&lt;/button&gt;
&lt;button id="clock_clear_console"&gt;清除&lt;/button&gt;
&lt;button id="clock_clear_container"&gt;清除畫布&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="clock_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;
&lt;div id="clock_container"&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;基本物件導向與案例&lt;/h2&gt;
&lt;p&gt;Python 採用類別 (class) 將案例變數 (instance variables) 與案例方法 (instance methods) 包在一起, 並用來定義一種物件 (object).&lt;/p&gt;
&lt;p&gt;物件導向具有封裝 (encapsulation) , 繼承 (inheritance) 與多形 ( polymorphism) 等三種特性.&lt;/p&gt;
&lt;!-- oop 範例 --&gt;

&lt;p&gt;使用者可以利用下列程式練習 Python3 物件的定義與應用.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

Ace = ace.Editor(editor_id="oop1_editor", console_id="oop1_console", container_id="oop1_container", storage_id="oop1_py_src" )

Ace.editor.setValue('''# Robot class 定義
class Robot(object):
    def __init__(self, name, by):
        self._name = name
        self._build_year = by

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, newname):
        self._name = name

    @property
    def build_year(self):
        return self._build_year

    @build_year.setter
    def build_year(self, newby):
        self._build_year = newby

x = Robot("bob", 1993)
x.build_year = 1993
print(x.name)
print(x.build_year)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['oop1_run'].bind('click', Ace.run)
doc['oop1_show_console'].bind('click', Ace.show_console)
doc['oop1_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="oop1_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="oop1_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('oop1_py_src', 'oop1_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="oop1_run"&gt;Run&lt;/button&gt;
&lt;button id="oop1_show_console"&gt;Output&lt;/button&gt;
&lt;button id="oop1_clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="oop1_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;!-- 必須處理重複執行後機構模擬產生錯誤的問題 --&gt;

&lt;p&gt;以下平面機構動態模擬程式, 僅提供參考.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

Ace = ace.Editor(editor_id="link_editor", console_id="link_console", container_id="fourbar", storage_id="link_py_src" )

Ace.editor.setValue('''# 導入所需模組
from browser import document as doc
from browser import window
from browser import timer
from browser import html
import math

# 利用 window 擷取 PrairieDraw 程式庫變數物件, 然後以 new 方法轉為 Brython 變數
pdraw = window.PrairieDraw.new
# 利用 window 擷取 PrairieDrawAnim 程式庫變數物件, 然後以 new 方法轉為 Brython 變數
PrairieDrawAnim = window.PrairieDrawAnim.new

# 利用 window 擷取 sylvester 程式庫變數物件 Vector, 並將其 create 方法直接轉為 Brython 變數
# 在 sylvester 中的 $V 簡化變數無法直接在 Brython 程式中引用
vector = window.Vector.create

# 在 "fourbar" 畫布中建立 panim 動態模擬案例
panim = PrairieDrawAnim("fourbar")

# 平面連桿繪圖以 t = 0 起始
t = 0
# 控制轉動方向變數
direction = True

# 繪製不同 t 時間下的平面連桿
def draw():
    global t, direction, fast
    # 設定模擬繪圖範圍
    panim.setUnits(6, 6)
    # 設定箭頭線寬
    panim.setProp("arrowLineWidthPx",2)

    # 起始變數設定
    omega = 1
    length_bar1 = 1
    length_bar2 = 26/18
    length_bar3 = 2
    length_base = 40/18
    time = 0

    # 畫出地面直線
    G = vector([0, -0.5])
    panim.ground(G, vector([0, 1]), 10)

    # 連桿長度與角度計算
    A = t*omega # "theta"
    AD = length_bar1 #length of left bar
    AB = length_base #distance between two stationary pivots
    BC = length_bar3 #length of right bar
    CD = length_bar2 #length of middle bar
    BD = math.sqrt(AD*AD + AB*AB - 2*AD*AB*math.cos(A))
    C = math.acos((BC*BC + CD*CD - BD*BD)/(2*BC*CD))
    ABD = math.asin(CD * math.sin(C) / BD)
    DBC = math.asin(AD * math.sin(A) / BD)
    B = ABD + DBC
    D = math.pi - B - C

    # draw pivot
    pivot_left = vector([AB/-2, 0])
    pivot_right = vector([AB/2, 0])
    panim.pivot(vector([pivot_left.e(1), -0.5]), pivot_left, 0.5)
    panim.pivot(vector([pivot_right.e(1), -0.5]), pivot_right, 0.5)

    # 儲存轉換矩陣
    panim.save()
    #FIRST BAR
    panim.translate(pivot_left)
    panim.rotate(A)
    panim.rod(vector([0,0]), vector([AD,0]), 0.25)
    panim.point(vector([0,0]))

    #SECOND BAR
    panim.translate(vector([AD,0]))
    panim.rotate(A*-1)  #"undo" the original A rotation
    panim.rotate(D)     #rotate by D only
    panim.rod(vector([0,0]), vector([CD,0]), 0.25)
    panim.point(vector([0,0]))

    #THIRD BAR
    panim.translate(vector([CD,0]))
    panim.rotate(math.pi+C)
    panim.rod(vector([0,0]), vector([BC,0]), 0.25)
    panim.point(vector([0,0]))
    # 回復原先的轉換矩陣
    panim.restore()

    panim.point(vector([pivot_right.e(1), 0]))
    # 時間增量
    if direction == True:
        t += 0.08
    else:
        t += -0.08

# 先畫出 t = 0 的連桿機構
draw()

# 將 anim 設為 None
anim = None

def launchAnimation(ev):
    global anim
    # 初始啟動, anim 為 None
    if anim is None:
        # 每 0.08 秒執行一次 draw 函式繪圖
        anim = timer.set_interval(draw, 80)
        # 初始啟動後, 按鈕文字轉為"暫停"
        doc['power'].text = '暫停'
    elif anim == 'hold':
        # 當 anim 為 'hold' 表示曾經暫停後的啟動, 因此持續以 set_interval() 持續旋轉, 且將 power 文字轉為"暫停"
        anim = timer.set_interval(draw, 80)
        doc['power'].text = '暫停'
    else:
        # 初始啟動後, 使用者再按 power, 此時 anim 非 None 也不是 'hold', 因此會執行 clear_interval() 暫停
        # 且將 anim 變數設為 'hold', 且 power 文字轉為"繼續"
        timer.clear_interval(anim)
        anim = 'hold'
        doc['power'].text = '繼續'

def reverse(ev):
    global anim, direction
    # 當 anim 為 hold 時, 按鈕無效
    if anim != "hold":
        if direction == True:
            direction = False
        else:
            direction = True

doc["power"].bind("click", launchAnimation)
doc["reverse"].bind("click", reverse)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['link_run'].bind('click', Ace.run)
doc['link_show_console'].bind('click', Ace.show_console)
doc['link_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="link_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="link_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('link_py_src', 'link_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="link_run"&gt;Run&lt;/button&gt;
&lt;button id="link_show_console"&gt;Output&lt;/button&gt;
&lt;button id="link_clear_console"&gt;清除&lt;/button&gt;
&lt;button id="power"&gt;啟動&lt;/button&gt;
&lt;button id="reverse"&gt;反向&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="link_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;
&lt;canvas id="fourbar" width="250" height="250"&gt;&lt;/canvas&gt;&lt;/p&gt;
&lt;h2&gt;平面機構運動模擬&lt;/h2&gt;
&lt;p&gt;以下為 Jansen's 八連桿機構的基本 Kinematic 運算, 先採用 Sympy 以符號式推導出機構端點的運動軌跡方程式後, 利用 Python 執行數值分析運算, 列出機構端點的座標.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
# 表示要導入 data/py/ace.py
import ace

Ace = ace.Editor(editor_id="jansen_editor", console_id="jansen_console", container_id="jansen_container", storage_id="jansen_py_src" )

Ace.editor.setValue('''#jansen 多連桿機構驗算
from math import pi, cos, sin, sqrt, acos

radian = 180/pi
degree = pi/180

#PLAP
def plap(ax, ay, ac, bac, bx, by, ccw):
    if ccw == 1:
        cx= ac*cos(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax 
        cy= ac*sin(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay
    else:
        cx= ac*cos(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax 
        cy= ac*sin(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay
    return cx, cy

#PLLP
def pllp(ax, ay, ac, cb, bx, by, cw):
    if cw == 1:
        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 - sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(-ax + bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
    else:
        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
    return cx, cy

ax = -38
ay = 0
# b 為原點
bx = 0
by = 0
cx = 0
cy = 7.8
# m 為配合 PLAP 新增固定點
mx = 30
my = 7.8
# dcm ccw 方向角度
dcm = 30*degree
cd = 15
# 三角形 dcm 為 ccw plap d=(a, cd, dcm, m)
dx, dy = plap(cx, cy, cd, dcm, mx, my, ccw=1)
print("dx=", dx, "dy=", dy)
# 三角形 aed 為 cw pllp e=(a, ae, ed, d)
ae = 41.5
ed = 50
ex, ey = pllp(ax, ay, ae, ed, dx, dy, cw=1)
print("ex=", ex, "ey=", ey)
# 三角形 afe 為 cw pllp f=(a, af, fe, e)
af = 40.1
fe = 55.8
fx, fy = pllp(ax, ay, af, fe, ex, ey, cw=1)
print("fx=", fx, "fy=", fy)
# 三角形 dha 為 cw pllp h=(d, dh, ha, a)
dh = 61.9
ha = 39.3
hx, hy = pllp(dx, dy, dh, ha, ax, ay, cw=1)
print("hx=", hx, "hy=", hy)
# 三角形 hgf 為 cw pllp g=(h, hg, gf, f)
hg = 36.7
gf = 39.4
gx, gy = pllp(hx, hy, hg, gf, fx, fy, cw=1)
print("gx=", gx, "gy=", gy)
# 三角形 hkg 為 cw pllp k=(h, hk, kg, g)
hk = 49
kg = 65.7
kx, ky = pllp(hx, hy, hk, kg, gx, gy, cw=1)
print("kx=", kx, "ky=", ky)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['jansen_run'].bind('click', Ace.run)
doc['jansen_show_console'].bind('click', Ace.show_console)
doc['jansen_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="jansen_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="jansen_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('jansen_py_src', 'jansen_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="jansen_run"&gt;Run&lt;/button&gt;
&lt;button id="jansen_show_console"&gt;Output&lt;/button&gt;
&lt;button id="jansen_clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="jansen_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;以下為與上述 Jansen's 八連桿機構對應的座標驗證圖, 機構端點座標 kx= -30.81 ky= -84.02:&lt;/p&gt;
&lt;p&gt;&lt;img src="./../images/jansen_sympy.png" width="800" height="600"&gt;&lt;/img&gt;&lt;/p&gt;
&lt;h2&gt;平面機構數目合成&lt;/h2&gt;
&lt;p&gt;itertools module implements a number of iterator building blocks.&lt;/p&gt;
&lt;p&gt;itertools.product(*iterables, repeat=1) - Cartesian product of input iterables.&lt;/p&gt;
&lt;p&gt;根據 &lt;a href="http://www.iftomm2015.tw/IFToMM2015CD/PDF/OS2-048.pdf"&gt;http://www.iftomm2015.tw/IFToMM2015CD/PDF/OS2-048.pdf&lt;/a&gt; (or &lt;a href="./../data/pdf/An_Algorithm_for_the_Automatic_Sketching_of_Generalized_Kinematic_Chains.pdf"&gt;local download&lt;/a&gt;)&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
# 表示要導入 data/py/ace.py
import ace

Ace = ace.Editor(editor_id="numsyn_editor", console_id="numsyn_console", container_id="numsyn_container", storage_id="numsyn_py_src" )

Ace.editor.setValue('''#數目合成
from itertools import product

# NL links and NJ joints as inputs
class NumberSynthesis:
    def __init__(self, NL, NJ):
        self.NL = NL
        self.NJ = NJ

    @property
    def Mmax(self):
        if self.NL &lt;= self.NJ and self.NJ &lt;= (2*self.NL-3):
            return self.NJ - self.NL + 2
        elif (2*self.NL-3) &lt;= self.NJ and self.NJ &lt;= (self.NL*(self.NL-1)/2):
            return self.NL - 1
        else:
            raise ValueError("incorrect number.")

    @property
    def NLm(self):
        result = []
        correction = lambda l: sum((i+2)*l[i] for i in range(len(l))) == 2*self.NJ
        for symbols in product(range(self.NL+1), repeat=self.Mmax-2):
            NLMmax = self.NL - sum(symbols)
            answer = symbols+(NLMmax,)
            if correction(answer) and NLMmax&gt;=0:
                result.append(answer)
        return tuple(result)

a = NumberSynthesis(9, 11)
print("the maximum number of joints incident to a link: ", a.Mmax)
print("link assortments of the generalized kinematic chains: ", a.NLm)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['numsyn_run'].bind('click', Ace.run)
doc['numsyn_show_console'].bind('click', Ace.show_console)
doc['numsyn_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="numsyn_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="numsyn_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('numsyn_py_src', 'numsyn_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="numsyn_run"&gt;Run&lt;/button&gt;
&lt;button id="numsyn_show_console"&gt;Output&lt;/button&gt;
&lt;button id="numsyn_clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="numsyn_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;目前所在頁面, 分別利用 &lt;a href="http://brython.info/"&gt;Brython&lt;/a&gt; 與 &lt;a href="https://ace.c9.io/"&gt;Ace&lt;/a&gt; 編輯器, 可直接在網誌中執行 Python3 程式, 基本架構為將 &lt;a href="http://brython.info/"&gt;Brython&lt;/a&gt; 的標準輸出轉到特定 div 標註, 而 &lt;a href="https://ace.c9.io/"&gt;Ace&lt;/a&gt; 編輯器則設為與其內的程式碼相同長度, 但至多只會在頁面中顯示 20 行, 且編輯器內的程式碼使用 12 號字元.&lt;/p&gt;
&lt;p&gt;ace.py 原始碼, 位於 static 目錄中, 將原先只能單一呼叫的函式改為物件, 可以在同一頁面中產生案例時, 透過各標註的 id 字串區分各段程式碼, 是本課程 Python3 物件導向程式的實際應用範例, 謹提供參考.&lt;/p&gt;</content><category term="2018FallCP"></category></entry><entry><title>Python Getting Started</title><link href="https://mdekmol.github.io/cd2019b-task1-2019cdb_t1_g3_1/blog/cd2019b-task1-2019cdb-t1-g3-1/PythonGettingStarted.html" rel="alternate"></link><published>2018-09-11T11:00:00+08:00</published><updated>2018-09-11T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:mdekmol.github.io,2018-09-11:/cd2019b-task1-2019cdb_t1_g3_1/blog/cd2019b-task1-2019cdb-t1-g3-1/PythonGettingStarted.html</id><summary type="html">&lt;p&gt;以下程式架構取自 &lt;a href="http://lab.kmol.info/blog/brython-programming-environment.html"&gt;http://lab.kmol.info/blog/brython-programming-environment.html&lt;/a&gt;, 使用 static/py/ 目錄中的 ace.py 程式定義.&lt;/p&gt;


&lt;!-- 導入 FileSaver 與 filereader --&gt;

&lt;script type="text/javascript" src="./../static/ace/FileSaver.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../static/ace/filereader.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../static/brython.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../static/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 導入平面機構模擬所需程式庫 --&gt;

&lt;!-- sylvester.js 為向量、矩陣與幾何程式庫 http://sylvester.jcoglan.com/ --&gt;

&lt;script src="./../static/sylvester/sylvester.js"&gt;&lt;/script&gt;

&lt;!-- PrairieDraw.js 為延伸 sylvester.js 的 html5 canvas 繪圖應用程式庫 https://github.com/martin70/PrairieDraw.js --&gt;

&lt;script src="./../static/sylvester/PrairieDraw.js"&gt;&lt;/script&gt;

&lt;style&gt;
canvas {
    border: 1px solid black;
}
&lt;/style&gt;

&lt;script&gt;
window.onload=function(){
brython({debug:1, pythonpath:['./../static']});
}
&lt;/script&gt;

&lt;!-- 以下執行 Brython 程式 --&gt;

&lt;script src="./../static/ace/ace.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../static/ace/ext-language_tools.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../static/ace/mode-python3.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../static/ace/snippets/python.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--&gt;

&lt;script type="text/javascript"&gt;
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob …&lt;/script&gt;</summary><content type="html">&lt;p&gt;以下程式架構取自 &lt;a href="http://lab.kmol.info/blog/brython-programming-environment.html"&gt;http://lab.kmol.info/blog/brython-programming-environment.html&lt;/a&gt;, 使用 static/py/ 目錄中的 ace.py 程式定義.&lt;/p&gt;


&lt;!-- 導入 FileSaver 與 filereader --&gt;

&lt;script type="text/javascript" src="./../static/ace/FileSaver.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../static/ace/filereader.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../static/brython.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../static/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 導入平面機構模擬所需程式庫 --&gt;

&lt;!-- sylvester.js 為向量、矩陣與幾何程式庫 http://sylvester.jcoglan.com/ --&gt;

&lt;script src="./../static/sylvester/sylvester.js"&gt;&lt;/script&gt;

&lt;!-- PrairieDraw.js 為延伸 sylvester.js 的 html5 canvas 繪圖應用程式庫 https://github.com/martin70/PrairieDraw.js --&gt;

&lt;script src="./../static/sylvester/PrairieDraw.js"&gt;&lt;/script&gt;

&lt;style&gt;
canvas {
    border: 1px solid black;
}
&lt;/style&gt;

&lt;script&gt;
window.onload=function(){
brython({debug:1, pythonpath:['./../static']});
}
&lt;/script&gt;

&lt;!-- 以下執行 Brython 程式 --&gt;

&lt;script src="./../static/ace/ace.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../static/ace/ext-language_tools.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../static/ace/mode-python3.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../static/ace/snippets/python.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--&gt;

&lt;script type="text/javascript"&gt;
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
&lt;/script&gt;

&lt;p&gt;編寫 Python3 程式邏輯之前必須先了解基本的程式語法, 其中包括:&lt;/p&gt;
&lt;h2&gt;Python3 變數命名規則與關鍵字&lt;/h2&gt;
&lt;p&gt;Python 英文變數命名規格&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;變數必須以英文字母大寫或小寫或底線開頭
變數其餘字元可以是英文大小寫字母, 數字或底線
變數區分英文大小寫
變數不限字元長度
不可使用關鍵字當作變數名稱
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用者可以利用以下程式列出所使用 Python 的版次與關鍵字:&lt;/p&gt;
&lt;!-- 印出版次與關鍵字程式 --&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="kw_editor", console_id="kw_console", container_id="kw__container", storage_id="kw_py_src" )

Ace.editor.setValue('''# 導入 sys 模組
import sys
# 導入 keyword 模組
import keyword

# 利用 sys 模組中的 version_info 印出 Python 版次
print("Python version: ", sys.version_info)
# 利用 keyword 模組中的 kwlist 印出關鍵字
print("Python keywords: ", keyword.kwlist)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run'].bind('click', Ace.run)
doc['kw_show_console'].bind('click', Ace.show_console)
doc['kw_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="kw_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="kw_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('kw_py_src', 'kw_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="kw_run"&gt;Run&lt;/button&gt;
&lt;button id="kw_show_console"&gt;Output&lt;/button&gt;
&lt;button id="kw_clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="kw_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Python3 的程式關鍵字, 使用者命名變數時, 必須避開下列保留字.&lt;/p&gt;
&lt;p&gt;Python keywords:  ['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']&lt;/p&gt;
&lt;p&gt;選擇好的變數名稱:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;使用有意義且適當長度的變數名稱， 例如: 使用 length 代表長度, 不要單獨使用 l 或 L, 也不要使用 this_is_the_length
程式前後變數命名方式盡量一致, 例如: 使用 rect_length 或 RectLength
用底線開頭的變數通常具有特殊意義
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;print() 函式用法&lt;/h2&gt;
&lt;p&gt;print() 為 Python 程式語言中用來列印數值或字串的函式, 其中有 sep 變數定義分隔符號, sep 內定為 ",", end 變數則用來定義列印結尾的符號, end 內定為跳行符號.&lt;/p&gt;
&lt;h2&gt;for 迴圈用法與 Python 的縮排規定&lt;/h2&gt;
&lt;p&gt;重複迴圈用法, 使用者可以透過下列程式編輯區練習 for 迴圈與 print() 函式的用法.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

Ace = ace.Editor(editor_id="editor", console_id="console", container_id="first_container", storage_id="py_src" )

Ace.editor.setValue('''#ex1 簡單的 for 迴圈範例
for i in range(10):
    print(i)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['run'].bind('click', Ace.run)
doc['show_console'].bind('click', Ace.show_console)
doc['clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('py_src', 'filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="run"&gt;Run&lt;/button&gt;
&lt;button id="show_console"&gt;Output&lt;/button&gt;
&lt;button id="clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;函式用法與呼叫&lt;/h2&gt;
&lt;p&gt;使用者可以利用下列程式, 練習 def 函式定義與呼叫的用法.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

Ace = ace.Editor(editor_id="fun_editor", console_id="fun_console", container_id="fun_container", storage_id="fun_py_src" )

Ace.editor.setValue('''# 定義函式
def square_of_x(x):
    return x*x

# 呼叫函式
y = square_of_x(3)
# 列印 y 對應內容
print(y)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['fun_run'].bind('click', Ace.run)
doc['fun_show_console'].bind('click', Ace.show_console)
doc['fun_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="fun_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="fun_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('fun_py_src', 'fun_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="fun_run"&gt;Run&lt;/button&gt;
&lt;button id="fun_show_console"&gt;Output&lt;/button&gt;
&lt;button id="fun_clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="fun_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;!-- Brython 的網際繪圖 --&gt;

&lt;p&gt;以下網際繪圖程式, 僅提供參考.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

Ace = ace.Editor(editor_id="by_editor", console_id="by_console", container_id="by_container", storage_id="by_py_src" )

Ace.editor.setValue('''# First of all, the import of some libraries
from browser import document as doc
from browser import html

# All the elements will be inserted in the div with the "container" id
container = doc['by_container']

# We create a new div element
newdiv = html.DIV(id = "new-div")
# Now we add some style
newdiv.style = {"padding": "5px", 
               "backgroundColor": "#ADD8E6"}

# Now, lets add a table with a column with numbers and a
# column with a word on each cell
text = "Brython is really cool"
textlist = text.split()
table = html.TABLE()
for i, word in enumerate(textlist):
    table &lt;= html.TR(html.TD(i + 1) + 
                     html.TD(word))
# Now we add some style to the table
table.style = {"padding": "5px", 
               "backgroundColor": "#aaaaaa",
               "width": "100%"}
# Now we add the table to the new div previously created
newdiv &lt;= table + html.BR()

# a form? why not?
form = html.FORM()
input1 = html.INPUT(type="text", name="firstname", value="First name")
input2 = html.INPUT(type="text", name="lastname", value="Last name")
input3 = html.BUTTON("Button with no action!")
form &lt;= input1 + html.BR() + input2 + html.BR() + input3

newdiv &lt;= form + html.BR()

# Finally, we will add something more 'HTML5istic', a canvas with
# a color gradient in the newdiv previously created and below the form
canvas = html.CANVAS(width = 300, height = 300)
#canvas.style = {"width": "100%"}
ctx = canvas.getContext('2d')
ctx.rect(0, 0, 300, 300)
grd = ctx.createRadialGradient(150, 150, 10, 150, 150, 150)
grd.addColorStop(0, '#8ED6FF')
grd.addColorStop(1, '#004CB3')
ctx.fillStyle = grd
ctx.fill()

newdiv &lt;= canvas
# And finally we append the newdiv element
# to the parent, in this case the div with the "container" id
container &lt;= newdiv
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['by_run'].bind('click', Ace.run)
doc['by_show_console'].bind('click', Ace.show_console)
doc['by_clear_console'].bind('click', Ace.clear_console)
doc['by_clear_container'].bind('click', Ace.clear_container)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="by_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="by_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('by_py_src', 'by_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="by_run"&gt;Run&lt;/button&gt;
&lt;button id="by_show_console"&gt;Output&lt;/button&gt;
&lt;button id="by_clear_console"&gt;清除&lt;/button&gt;
&lt;button id="by_clear_container"&gt;清除畫布&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="by_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;
&lt;div id="by_container"&gt;&lt;/div&gt;&lt;/p&gt;
&lt;!-- Brython 動畫 --&gt;

&lt;p&gt;以下網際動態繪圖程式, 僅提供參考.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

Ace = ace.Editor(editor_id="clock_editor", console_id="clock_console", container_id="clock_container", storage_id="clock_py_src" )

Ace.editor.setValue('''# First of all, the import of some libraries
import time
import math
import datetime
from browser import document as doc
import browser.timer
from browser import html

sin,cos = math.sin,math.cos
width,height = 250,250 # canvas dimensions
ray = 100 # clock ray

# All the elements will be inserted in the div with the "container" id
container = doc['clock_container']

# We create a new div element
newdiv = html.DIV(id = "new-div")
# Now we add some style
newdiv.style = {"padding": "5px", 
               "backgroundColor": "#ADD8E6"}

canvas = html.CANVAS(width = width, height = height)
#canvas.style = {"width": "100%"}
ctx = canvas.getContext('2d')

def needle(angle,r1,r2,color="#000000"):
    # draw a needle at specified angle in specified color
    # r1 and r2 are percentages of clock ray
    x1 = width/2-ray*cos(angle)*r1
    y1 = height/2-ray*sin(angle)*r1
    x2 = width/2+ray*cos(angle)*r2
    y2 = height/2+ray*sin(angle)*r2
    ctx.beginPath()
    ctx.strokeStyle = color
    ctx.moveTo(x1,y1)
    ctx.lineTo(x2,y2)
    ctx.stroke()

def set_clock():
    # erase clock
    ctx.beginPath()
    ctx.fillStyle = "#FFF"
    ctx.arc(width/2,height/2,ray*0.89,0,2*math.pi)
    ctx.fill()

    # redraw hours
    show_hours()

    # print day
    now = datetime.datetime.now()
    day = now.day
    ctx.font = "bold 14px Arial"
    ctx.textAlign = "center"
    ctx.textBaseline = "middle"
    ctx.fillStyle="#FFF"
    ctx.fillText(day,width*0.7,height*0.5)

    # draw needles for hour, minute, seconds    
    ctx.lineWidth = 3
    hour = now.hour%12 + now.minute/60
    angle = hour*2*math.pi/12 - math.pi/2
    needle(angle,0.05,0.5)
    minute = now.minute
    angle = minute*2*math.pi/60 - math.pi/2
    needle(angle,0.05,0.85)
    ctx.lineWidth = 1
    second = now.second+now.microsecond/1000000
    angle = second*2*math.pi/60 - math.pi/2
    needle(angle,0.05,0.85,"#FF0000") # in red

browser.timer.set_interval(set_clock,100)

ctx.beginPath()
ctx.lineWidth = 10
ctx.arc(width/2,height/2,ray,0,2*math.pi)
ctx.stroke()

for i in range(60):
    ctx.lineWidth = 1
    if i%5 == 0:
        ctx.lineWidth = 3
    angle = i*2*math.pi/60 - math.pi/3
    x1 = width/2+ray*cos(angle)
    y1 = height/2+ray*sin(angle)
    x2 = width/2+ray*cos(angle)*0.9
    y2 = height/2+ray*sin(angle)*0.9
    ctx.beginPath()
    ctx.moveTo(x1,y1)
    ctx.lineTo(x2,y2)
    ctx.stroke()

def show_hours():
    ctx.beginPath()
    ctx.arc(width/2,height/2,ray*0.05,0,2*math.pi)
    ctx.fillStyle = "#000"
    ctx.fill()
    for i in range(1,13):
        angle = i*math.pi/6-math.pi/2
        x3 = width/2+ray*cos(angle)*0.75
        y3 = height/2+ray*sin(angle)*0.75
        ctx.font = "20px Arial"
        ctx.textAlign = "center"
        ctx.textBaseline = "middle"
        ctx.fillText(i,x3,y3)
    # cell for day
    ctx.fillStyle = "#000"
    ctx.fillRect(width*0.65,height*0.47,width*0.1,height*0.06)

show_hours()
set_clock()

newdiv &lt;= canvas
# And finally we append the newdiv element
# to the parent, in this case the div with the "container" id
container &lt;= newdiv
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['clock_run'].bind('click', Ace.run)
doc['clock_show_console'].bind('click', Ace.show_console)
doc['clock_clear_console'].bind('click', Ace.clear_console)
doc['clock_clear_container'].bind('click', Ace.clear_container)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="clock_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="clock_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('clock_py_src', 'clock_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="clock_run"&gt;Run&lt;/button&gt;
&lt;button id="clock_show_console"&gt;Output&lt;/button&gt;
&lt;button id="clock_clear_console"&gt;清除&lt;/button&gt;
&lt;button id="clock_clear_container"&gt;清除畫布&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="clock_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;
&lt;div id="clock_container"&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;基本物件導向與案例&lt;/h2&gt;
&lt;p&gt;Python 採用類別 (class) 將案例變數 (instance variables) 與案例方法 (instance methods) 包在一起, 並用來定義一種物件 (object).&lt;/p&gt;
&lt;p&gt;物件導向具有封裝 (encapsulation) , 繼承 (inheritance) 與多形 ( polymorphism) 等三種特性.&lt;/p&gt;
&lt;!-- oop 範例 --&gt;

&lt;p&gt;使用者可以利用下列程式練習 Python3 物件的定義與應用.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

Ace = ace.Editor(editor_id="oop1_editor", console_id="oop1_console", container_id="oop1_container", storage_id="oop1_py_src" )

Ace.editor.setValue('''# Robot class 定義
class Robot(object):
    def __init__(self, name, by):
        self._name = name
        self._build_year = by

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, newname):
        self._name = name

    @property
    def build_year(self):
        return self._build_year

    @build_year.setter
    def build_year(self, newby):
        self._build_year = newby

x = Robot("bob", 1993)
x.build_year = 1993
print(x.name)
print(x.build_year)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['oop1_run'].bind('click', Ace.run)
doc['oop1_show_console'].bind('click', Ace.show_console)
doc['oop1_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="oop1_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="oop1_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('oop1_py_src', 'oop1_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="oop1_run"&gt;Run&lt;/button&gt;
&lt;button id="oop1_show_console"&gt;Output&lt;/button&gt;
&lt;button id="oop1_clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="oop1_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;!-- 必須處理重複執行後機構模擬產生錯誤的問題 --&gt;

&lt;p&gt;以下平面機構動態模擬程式, 僅提供參考.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

Ace = ace.Editor(editor_id="link_editor", console_id="link_console", container_id="fourbar", storage_id="link_py_src" )

Ace.editor.setValue('''# 導入所需模組
from browser import document as doc
from browser import window
from browser import timer
from browser import html
import math

# 利用 window 擷取 PrairieDraw 程式庫變數物件, 然後以 new 方法轉為 Brython 變數
pdraw = window.PrairieDraw.new
# 利用 window 擷取 PrairieDrawAnim 程式庫變數物件, 然後以 new 方法轉為 Brython 變數
PrairieDrawAnim = window.PrairieDrawAnim.new

# 利用 window 擷取 sylvester 程式庫變數物件 Vector, 並將其 create 方法直接轉為 Brython 變數
# 在 sylvester 中的 $V 簡化變數無法直接在 Brython 程式中引用
vector = window.Vector.create

# 在 "fourbar" 畫布中建立 panim 動態模擬案例
panim = PrairieDrawAnim("fourbar")

# 平面連桿繪圖以 t = 0 起始
t = 0
# 控制轉動方向變數
direction = True

# 繪製不同 t 時間下的平面連桿
def draw():
    global t, direction, fast
    # 設定模擬繪圖範圍
    panim.setUnits(6, 6)
    # 設定箭頭線寬
    panim.setProp("arrowLineWidthPx",2)

    # 起始變數設定
    omega = 1
    length_bar1 = 1
    length_bar2 = 26/18
    length_bar3 = 2
    length_base = 40/18
    time = 0

    # 畫出地面直線
    G = vector([0, -0.5])
    panim.ground(G, vector([0, 1]), 10)

    # 連桿長度與角度計算
    A = t*omega # "theta"
    AD = length_bar1 #length of left bar
    AB = length_base #distance between two stationary pivots
    BC = length_bar3 #length of right bar
    CD = length_bar2 #length of middle bar
    BD = math.sqrt(AD*AD + AB*AB - 2*AD*AB*math.cos(A))
    C = math.acos((BC*BC + CD*CD - BD*BD)/(2*BC*CD))
    ABD = math.asin(CD * math.sin(C) / BD)
    DBC = math.asin(AD * math.sin(A) / BD)
    B = ABD + DBC
    D = math.pi - B - C

    # draw pivot
    pivot_left = vector([AB/-2, 0])
    pivot_right = vector([AB/2, 0])
    panim.pivot(vector([pivot_left.e(1), -0.5]), pivot_left, 0.5)
    panim.pivot(vector([pivot_right.e(1), -0.5]), pivot_right, 0.5)

    # 儲存轉換矩陣
    panim.save()
    #FIRST BAR
    panim.translate(pivot_left)
    panim.rotate(A)
    panim.rod(vector([0,0]), vector([AD,0]), 0.25)
    panim.point(vector([0,0]))

    #SECOND BAR
    panim.translate(vector([AD,0]))
    panim.rotate(A*-1)  #"undo" the original A rotation
    panim.rotate(D)     #rotate by D only
    panim.rod(vector([0,0]), vector([CD,0]), 0.25)
    panim.point(vector([0,0]))

    #THIRD BAR
    panim.translate(vector([CD,0]))
    panim.rotate(math.pi+C)
    panim.rod(vector([0,0]), vector([BC,0]), 0.25)
    panim.point(vector([0,0]))
    # 回復原先的轉換矩陣
    panim.restore()

    panim.point(vector([pivot_right.e(1), 0]))
    # 時間增量
    if direction == True:
        t += 0.08
    else:
        t += -0.08

# 先畫出 t = 0 的連桿機構
draw()

# 將 anim 設為 None
anim = None

def launchAnimation(ev):
    global anim
    # 初始啟動, anim 為 None
    if anim is None:
        # 每 0.08 秒執行一次 draw 函式繪圖
        anim = timer.set_interval(draw, 80)
        # 初始啟動後, 按鈕文字轉為"暫停"
        doc['power'].text = '暫停'
    elif anim == 'hold':
        # 當 anim 為 'hold' 表示曾經暫停後的啟動, 因此持續以 set_interval() 持續旋轉, 且將 power 文字轉為"暫停"
        anim = timer.set_interval(draw, 80)
        doc['power'].text = '暫停'
    else:
        # 初始啟動後, 使用者再按 power, 此時 anim 非 None 也不是 'hold', 因此會執行 clear_interval() 暫停
        # 且將 anim 變數設為 'hold', 且 power 文字轉為"繼續"
        timer.clear_interval(anim)
        anim = 'hold'
        doc['power'].text = '繼續'

def reverse(ev):
    global anim, direction
    # 當 anim 為 hold 時, 按鈕無效
    if anim != "hold":
        if direction == True:
            direction = False
        else:
            direction = True

doc["power"].bind("click", launchAnimation)
doc["reverse"].bind("click", reverse)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['link_run'].bind('click', Ace.run)
doc['link_show_console'].bind('click', Ace.show_console)
doc['link_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="link_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="link_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('link_py_src', 'link_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="link_run"&gt;Run&lt;/button&gt;
&lt;button id="link_show_console"&gt;Output&lt;/button&gt;
&lt;button id="link_clear_console"&gt;清除&lt;/button&gt;
&lt;button id="power"&gt;啟動&lt;/button&gt;
&lt;button id="reverse"&gt;反向&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="link_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;
&lt;canvas id="fourbar" width="250" height="250"&gt;&lt;/canvas&gt;&lt;/p&gt;
&lt;h2&gt;平面機構運動模擬&lt;/h2&gt;
&lt;p&gt;以下為 Jansen's 八連桿機構的基本 Kinematic 運算, 先採用 Sympy 以符號式推導出機構端點的運動軌跡方程式後, 利用 Python 執行數值分析運算, 列出機構端點的座標.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
# 表示要導入 data/py/ace.py
import ace

Ace = ace.Editor(editor_id="jansen_editor", console_id="jansen_console", container_id="jansen_container", storage_id="jansen_py_src" )

Ace.editor.setValue('''#jansen 多連桿機構驗算
from math import pi, cos, sin, sqrt, acos

radian = 180/pi
degree = pi/180

#PLAP
def plap(ax, ay, ac, bac, bx, by, ccw):
    if ccw == 1:
        cx= ac*cos(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax 
        cy= ac*sin(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay
    else:
        cx= ac*cos(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax 
        cy= ac*sin(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay
    return cx, cy

#PLLP
def pllp(ax, ay, ac, cb, bx, by, cw):
    if cw == 1:
        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 - sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(-ax + bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
    else:
        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
    return cx, cy

ax = -38
ay = 0
# b 為原點
bx = 0
by = 0
cx = 0
cy = 7.8
# m 為配合 PLAP 新增固定點
mx = 30
my = 7.8
# dcm ccw 方向角度
dcm = 30*degree
cd = 15
# 三角形 dcm 為 ccw plap d=(a, cd, dcm, m)
dx, dy = plap(cx, cy, cd, dcm, mx, my, ccw=1)
print("dx=", dx, "dy=", dy)
# 三角形 aed 為 cw pllp e=(a, ae, ed, d)
ae = 41.5
ed = 50
ex, ey = pllp(ax, ay, ae, ed, dx, dy, cw=1)
print("ex=", ex, "ey=", ey)
# 三角形 afe 為 cw pllp f=(a, af, fe, e)
af = 40.1
fe = 55.8
fx, fy = pllp(ax, ay, af, fe, ex, ey, cw=1)
print("fx=", fx, "fy=", fy)
# 三角形 dha 為 cw pllp h=(d, dh, ha, a)
dh = 61.9
ha = 39.3
hx, hy = pllp(dx, dy, dh, ha, ax, ay, cw=1)
print("hx=", hx, "hy=", hy)
# 三角形 hgf 為 cw pllp g=(h, hg, gf, f)
hg = 36.7
gf = 39.4
gx, gy = pllp(hx, hy, hg, gf, fx, fy, cw=1)
print("gx=", gx, "gy=", gy)
# 三角形 hkg 為 cw pllp k=(h, hk, kg, g)
hk = 49
kg = 65.7
kx, ky = pllp(hx, hy, hk, kg, gx, gy, cw=1)
print("kx=", kx, "ky=", ky)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['jansen_run'].bind('click', Ace.run)
doc['jansen_show_console'].bind('click', Ace.show_console)
doc['jansen_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="jansen_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="jansen_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('jansen_py_src', 'jansen_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="jansen_run"&gt;Run&lt;/button&gt;
&lt;button id="jansen_show_console"&gt;Output&lt;/button&gt;
&lt;button id="jansen_clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="jansen_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;以下為與上述 Jansen's 八連桿機構對應的座標驗證圖, 機構端點座標 kx= -30.81 ky= -84.02:&lt;/p&gt;
&lt;p&gt;&lt;img src="./../images/jansen_sympy.png" width="800" height="600"&gt;&lt;/img&gt;&lt;/p&gt;
&lt;h2&gt;平面機構數目合成&lt;/h2&gt;
&lt;p&gt;itertools module implements a number of iterator building blocks.&lt;/p&gt;
&lt;p&gt;itertools.product(*iterables, repeat=1) - Cartesian product of input iterables.&lt;/p&gt;
&lt;p&gt;根據 &lt;a href="http://www.iftomm2015.tw/IFToMM2015CD/PDF/OS2-048.pdf"&gt;http://www.iftomm2015.tw/IFToMM2015CD/PDF/OS2-048.pdf&lt;/a&gt; (or &lt;a href="./../data/pdf/An_Algorithm_for_the_Automatic_Sketching_of_Generalized_Kinematic_Chains.pdf"&gt;local download&lt;/a&gt;)&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
# 表示要導入 data/py/ace.py
import ace

Ace = ace.Editor(editor_id="numsyn_editor", console_id="numsyn_console", container_id="numsyn_container", storage_id="numsyn_py_src" )

Ace.editor.setValue('''#數目合成
from itertools import product

# NL links and NJ joints as inputs
class NumberSynthesis:
    def __init__(self, NL, NJ):
        self.NL = NL
        self.NJ = NJ

    @property
    def Mmax(self):
        if self.NL &lt;= self.NJ and self.NJ &lt;= (2*self.NL-3):
            return self.NJ - self.NL + 2
        elif (2*self.NL-3) &lt;= self.NJ and self.NJ &lt;= (self.NL*(self.NL-1)/2):
            return self.NL - 1
        else:
            raise ValueError("incorrect number.")

    @property
    def NLm(self):
        result = []
        correction = lambda l: sum((i+2)*l[i] for i in range(len(l))) == 2*self.NJ
        for symbols in product(range(self.NL+1), repeat=self.Mmax-2):
            NLMmax = self.NL - sum(symbols)
            answer = symbols+(NLMmax,)
            if correction(answer) and NLMmax&gt;=0:
                result.append(answer)
        return tuple(result)

a = NumberSynthesis(9, 11)
print("the maximum number of joints incident to a link: ", a.Mmax)
print("link assortments of the generalized kinematic chains: ", a.NLm)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['numsyn_run'].bind('click', Ace.run)
doc['numsyn_show_console'].bind('click', Ace.show_console)
doc['numsyn_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="numsyn_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="numsyn_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('numsyn_py_src', 'numsyn_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="numsyn_run"&gt;Run&lt;/button&gt;
&lt;button id="numsyn_show_console"&gt;Output&lt;/button&gt;
&lt;button id="numsyn_clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="numsyn_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;目前所在頁面, 分別利用 &lt;a href="http://brython.info/"&gt;Brython&lt;/a&gt; 與 &lt;a href="https://ace.c9.io/"&gt;Ace&lt;/a&gt; 編輯器, 可直接在網誌中執行 Python3 程式, 基本架構為將 &lt;a href="http://brython.info/"&gt;Brython&lt;/a&gt; 的標準輸出轉到特定 div 標註, 而 &lt;a href="https://ace.c9.io/"&gt;Ace&lt;/a&gt; 編輯器則設為與其內的程式碼相同長度, 但至多只會在頁面中顯示 20 行, 且編輯器內的程式碼使用 12 號字元.&lt;/p&gt;
&lt;p&gt;ace.py 原始碼, 位於 static 目錄中, 將原先只能單一呼叫的函式改為物件, 可以在同一頁面中產生案例時, 透過各標註的 id 字串區分各段程式碼, 是本課程 Python3 物件導向程式的實際應用範例, 謹提供參考.&lt;/p&gt;</content><category term="2018FallCP"></category></entry></feed>